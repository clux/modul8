# Brownie - Bake and glaze web applications

 Brownie is a code and style bundler for browser applications. It aims to compile everything you could possibly need into a two files;
 - a JavaScript bundle that comes with browser-wide require, pulling in shared code in a controlled way
 - a CSS bundle that pulls in your all your imports and can compile from Stylus [css bundler still in heavy development]
 The module system in brownie is inspired by [RequireJS](http://requirejs.org/), and should indeed be compatible with this,
 but brownie compiles everything in such a way that you won't need to.
 Brownie is implemented with CoffeeScript for [NodeJS](http://nodejs.org).

### version 1.0 almost ready to go!

## Features

  - client-side require (with several code domains as require paths)
  - bundles JavaScript or CoffeeScript
  - bundles classic window exporting libraries
  - compiles CommonJS modules to work with browser require
  - adds 50 lines of javascript to the head of the autogenerated JavaScript file (no extra file to include)
  - enforces modularity best practices (no circular dependencies allowed from the start, and helps analyse your require tree)
  - automatically resolves the require tree and concatenates your required scripts in the right order
  - allows dumping of the prettified require tree for full overview of your code
  - adding extra domains makes sharing code between the server and the client easy (automatically compiled for the browser)
  - pulls in external data to be requirable on the browser if configured.
  - minimizes browser global usage -> attaches you application data to the namespaced `window.(namespace || 'Brownie')`
  - ideal for single page web applications - potentially only 2 HTTP requests to get all your data

## Installation

via npm: coming


## Baking - Compiling scripts

```coffee
brownie = require 'brownie'
brownie.bake
  domains   : [
    ['shared',  dir+'/app/shared/']
    ['client',  dir+'/app/client/']
  ]
  libDir    : dir+'/app/client/lib/'
  libFiles  : ['jquery.js', 'history.js']
  target    : dir+'/public/js/target.js'
  minify    : environment is 'production'
```
### Options

 - `target`         File to write to (must be referenced by your template).
 - `minify`         Pass the the output file through [UglifyJS](http://github.com/mishoo/UglifyJS) before writing to disk. Defaults to false.
 - `minifier`       Pass in a function mapping a code string to a minified code string if you are not satisfied with UglifyJS compression/obfuscation.
 - `domains`        Array of pairs of form [nameofdomain, pathtodomain] in the order they should be scanned. Think of these as your require paths on the browser. You can define as many/few as you want, but you need at least a 'client' domain.
 We use an array for this interface rather than an object because order may become important. At the moment, all non-client code gets included first, then all the client code.
 - `data`           Object of form key,val == name, pull_fn. This will make the output of the pull_fn requireable on the browser under 'data::name'. Useful for generating dynamic (app specific) data in the targetjs.
 - `basePoint`      Base file where your app is launched. Defaults to 'app.coffee'. It must lie on the 'client' domain.
 - `namespace`      Global object to export everything to. Defaults to 'Brownie'. Unless you go digging in the output source, this should never need to be referenced directly.
 - `libDir`         Directory to find external libraries that you wish to include outside of the require system.
 - `libFiles`       List of files to include in order. Note: libDir+libFiles[i] must exist for all i.
 - `libsOnlyTarget` Optional file to write lib files to. Makes the output of brownie quickly distinguishable from your big libraries, and people won't have to redownload that part of the code everytime you change your app code.
 - `DOMLoadWrap`    Optional function which wraps a code string in a function that executes once the DOMContentLoaded event fires. Defaults to a jQuery wrapper.
 - `localTests`     Bool to determine whether to chuck the standalone module code before bundling/looking for dependencies. Avoids pulling in test dependencies or test code.
 It is a bit raw at the moment, as it indiscriminately chucks everything including the point 'require.main' is referenced in your code. Enable with caution for now.


There are also 4 optional booleans for configuring the prettified require tree:
 - `treeTarget`     Where to write the current prettified require tree to. Useful for code analysis. Not set by default.
 - `logTree`        Boolean to determine if you want the prettified dependency passed to console.log. Default false. If neither treeTarget nor logTree is set, then the remaining values are discarded.
 - `extSuffix`      Boolean to determine whether the extension name is suffixed to the name of each file in the require tree. Default true.
 - `domPrefix`      Boolean to determine whether the domain of the file is prefixed to the name of each file in the require tree. Default false.
### Notes on require()

There are four different ways to use require:
 - **Globally**       I.e. `require('subfolder/module.js')`. Here all the require paths (the domains) will be scanned for a matching subfolder and a module.js inside it.
 Global requires always starts searching on the domain you are currently at. If you were inside module.js and a sibling file in that folder existed as 'module2.js' then
 if you wanted to require that in the same way, i.e. `require('subfolder/module2.js')` even though you are doing it from inside subfolder.

 - **Relatively**     Alternatively, you could write `require('./module.js')` to indicate that you are looking only inside this folder on this domain. You can also go up from subfolder via
 `require('./../basemodule.js')` to get a basemodule.js in the parent directory from module.js. You can keep chaining on '../' to go up one more directory, but you cannot write a folder name then go up again.
 I.e. `require('./../subfolder/../basemodule.js')` **is not legal** in brownie even though it is technically correct syntax.

 - **Domain Specific**  `require('shared::fileonsharedpath.js')`. When seeing `::`, it tells brownie to only look in the domain named what's before that string. Otherwise it works like global requires.
 Domain specific + relative is either non-sensical (if cross domain - folder structure between domains is lost on the browser side), or unnecessary (if same origin domain) as relative require only looks in the current domain anyway.

 - **Data Domain**      `require('data::datakey')`. This emulates the domain specific require using the fixed 'data' domain. This domain is reserved and does not actually need (nor allow) a physical path.
 It is there to allow requiring of data that was passed in through the `data` option to `bake`. This domain is reserved so that brownie knows to exclude looking for these files during codeanalysis.


### require libraries
If you want consistency, then you might want to be able to ditch your dependence on global variables altogether.
There are ways you could do this, but they all seem unoptimal given what we are used to.

One way is creating an arbiter for jQuery on the client path with `exports.$ = window.jQuery` in it. This means you can use `$ = require('libs.coffee').$`
from inside your app code - and it libs will show up in your dependency tree. However, the client domain is not executed before `DOMContentLoaded` fires, which often is listened to by jQuery.
If you want to include fallback script loading in the arbiter - and you write a separate DOMLoadWrap function to deal - then this it still introduces a dealy on when your fallback executes.
Alternatively, you can put it on another domain specifically for this, and `require('newdom::libs.coffee').$` to avoid this, but it's a lot to type for whats normally available.

Another way is to create a data function to `bake`.

```coffee
brownie.bake
  #normal options
  data : {'$'  :  -> 'window.jQuery'}
```
Now you can simply `$ = require('data::$')`



### Glazing - Compiling stylesheets
In rapid development. The API will look something like this.

```coffee
brownie.glaze
  target : './public/css/target.css'
  minify : environment is 'production'
```


## License

(The MIT License)

Copyright (c) 2009-2010 Eirik Albrigtsen;

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
