<html>
  <head>
    <meta charset="utf8">
    <title>modul8 - modularity enforcing code packager and analyzer for nodejs web applications</title>
    <link rel='stylesheet' href='../main.css' />
  </head>
  <body class="subpage">
    <div id="content">
<h2>require()</h2>

<p>Modul8's <code>require()</code> works hand in hand with a private <code>define()</code> call that gets pre-pended to the compiled source.
On compilation each module is wrapped in a define call (ensuring encapsulation of private variables between modules) that give each of these modules
the necessary context for the <code>require()</code> calls it may make. All context is stored via closures and will be hidden from you.</p>

<h3>Ways to require</h3>

<p>There are four different ways to use require:</p>

<ul>
<li><p><strong>Globally</strong>:        <code>require('subfolder/module.js')</code>. This will scan all the domains (except data) for a matching structure, starting the search at your current location.
A gloabl require does not care about your current location.</p></li>
<li><p><strong>Relatively</strong>:      <code>require('./module.js')</code>. This will scan only the current domain and the current folder
You can keep chaining on '../' to go up directories, but this has to happen in the beginning of the require string:
<code>require('./../subfolder/../basemodule.js')</code> <strong>is not legal</strong> while <code>require('./../basemodule.js')</code> <strong>is</strong>.</p>

<ul><li><strong>Domain Specific</strong>  <code>require('shared::val.js')</code>. Scans the specified domain (only) as if it were a global require from within that domain.
You cannot do relative requires combined with domain prefixes as this is either non-sensical (cross domain case: folder structure between domains lost on the browser),
or unnecessary (same origin case: you should simply be using relative requires).</li></ul></li>
<li><p><strong>Data Domain</strong>:     <code>require('data::datakey')</code>. The data domain is special. It is there to allow requiring of data that was <code>add()</code>-chained on the <code>data()</code> method.
It does not arise from physical files, and will not show up in the dependency tree. It is simply data you have attached deliberately.</p></li>
<li><p><strong>Through Arbiters</strong> <code>require('jQuery')</code> - given that <code>arbiters().add('jQuery',['$','jQuery'])</code> was passed in on the server.
This will have deleted the global shortcuts included. Since these are probably commonly dependend upon they can be used without specifying their default domain: <code>M8::</code>.
Note that this domain name is not related to the namespace setting. If a jQuery.js file is found on the current domain, however, it will gain priority over the
arbiters domain. If this cooexistence is necessary, any arbiters must be <code>require()</code>d domainspecifically: <code>$ = require('M8::jQuery')</code>.</p></li>
</ul>

<h4>File extensions</h4>

<p>File extensions are never necessary, but you can (and sometimes should) include them for specificity (except for on the data domain).</p>

<p>To see why you perhaps should, consider the simplified algorithm <code>require()</code> uses to resolve the files you required on the server:</p>

<pre><code>name = require input, domain = current domait (stored in closure)
while(domain)
  return true if exists(domain + name)
  return true if exists(domain + name + '.js')
  return true if exists(domain + name + '.coffee')
  domain = nextDomain
return false
</code></pre>

<p>If there is one thing to learn from it is is that you absolutely <strong>DO NOT omit extensions and keep .js and .coffee versions in the same folder</strong>
 or you will quickly become very frustrated as to why your coffee changes arent doing anything.</p>

<h3>Require Priority</h3>

<p>Requires are attempted resolved with the following priority:</p>

<pre><code>if require string is relative
  resolve absolutized require string on current domain
else if require string includes domain prefix
  resolve require string on specified domain
else //arbiter search
  resolve require string on the M8 domain

if none of the above worked
  resolve on all other domains

//error
</code></pre>

<p>In other words, collisions should not occur unless you have duplicate files in different domains, and you are very relaxed about your domain specifiers or arbiter prefixes.</p>

<h3>Hooking into define</h3>

<p>modul8 defines way to help you attach objects/fn to certain domains both live on the client and from the server via <code>data()</code>.
The <a href="api.html">API docs</a> have full information on this.</p>    </div>
  </body>
</html>
