<html>
  <head>
    <meta charset="utf8">
    <title>modul8 - Extensible CommonJS browser code sharing</title>
    <link rel='stylesheet' href='../main.css' />
  </head>
  <body class="subpage">
    <ul id="nav">
      <li><a href="https://github.com/clux/modul8#readme" title="Source and introduction">Intro</a></li>
      <li><a href="https://github.com/clux/modul8/tree/master/examples" title="Examples from github source">Examples</a></li>
      <li><a href="api.html" title="API documentation">API</a></li>
      <li><a href="cli.html" title="using the Command Line Interface">CLI</a></li>
      <li><a href="plugins.html" title="available plugins, and how to write them">Plugins</a></li>
      <li><a href="require.html" title="require() types and priorities">require</a></li>
      <li><a href="npm.html" title="using node modules">npm</a></li>
      <li><a href="xcjs.html" title="Extended CommonJS: basic and extensions">X-CommonJS</a></li>
      <li><a href="modularity.html" title="Modularity: issues and advice">Modularity</a></li>
    </ul>
    <div id="content">
<h1>require()</h1>

<h2>Ways to require</h2>

<p>There are four different ways to use require from your application code:</p>

<h4>Relatively</h4>

<ul>
<li><code>require('./module.js')</code> - Can resolve a module.js file (only) on the current domain in the current folder.</li>
</ul>

<p>You can indicate a relative require by using either the <code>./</code> prefix, or the folder traversing <code>../</code> prefix. Going up folders is done by chaining on <code>../</code> strings.</p>

<h4>Absolutely</h4>

<ul>
<li><code>require('subfolder/module.js')</code> - Can resolve subfolder/module.js on any domain - regardless of what subfolder or domain you are in - but <strong>will scan the current domain first</strong>.</li>
</ul>

<p><strong>NB</strong>: Not recommended as a shorter substitution to relative requires, as collisions can appear.</p>

<h4>Domain Specific</h4>

<ul>
<li><code>require('shared::val.js')</code> - Like absolute requires, but specifies the only domain which will be searched. If you want to do relative domain specific requires,
just use a pure relative require where the current domain is implicitly assumed.</li>
</ul>

<p>Note that <code>require('dom::')</code> will look for an index file in the root of that domain. So if you want to minimize the cross-domain interaction,
export everything relevant from there.</p>

<h5>NPM Domain</h5>

<ul>
<li><code>require('npm::underscore')</code> - Will find the files from the specified node modules root. Node modules will show up in the dependency tree as a single file (SOON).</li>
</ul>

<h5>Data Domain</h5>

<ul>
<li><code>require('data::datakey')</code> - Data on this domain does not represent actual files, but data injected into the require system on the server. It will not show up in the dependency tree.</li>
</ul>

<h5>External Domain</h5>

<ul>
<li><code>require('external::extkey')</code> - Same as data domain, but only extensible from the client.</li>
</ul>

<h5>Arbiter Domain</h5>

<ul>
<li><code>require('jQuery')</code> - Shortcut domain for old globals that were deleted to help identify hidden dependencies - must be defined on the server.
This does not require a domain prefix because it is assumed this domain gets sufficiently frequent use to have it bumped up on the priority list.</li>
</ul>

<p>Note that if a jQuery.js file is found on the current domain, however, it will gain priority over the arbiter domain.
If this coexistence is necessary, any arbiters must be  required by specifying the internal domain name: <code>var $ = require('M8::jQuery')</code>.</p>

<h2>File extensions</h2>

<p>File extensions are never necessary, but you can (and sometimes should) include them for specificity (except for on the data domain).</p>

<p>The reason you perhaps should is that modul8 allows mixing and matching JavaScript, CoffeeScript, and other AltJS languages,
but is only as forgiving with such mixing as you deserve. If you only use one language and never put files of another language in your directories,
the following warning does not apply to you.</p>

<h3>Extension Priority</h3>

<p>To see why, consider a simplified resolver algorithm from the server</p>

<pre><code>name = require input
for domain in domainsScannable
  return true if exists(join(domain, name))
  return true if exists(join(domain, name + '.js'))
  return true if exists(join(domain, name + altJsExt)) //optional
return false
</code></pre>

<p>If you use <em>CoffeeScript</em> or other registered compilers for AltJS languages,
and if there is even a chance of a file of the same name with a <code>.js</code> extension popping up in the same folder,
then it will gain priority over your normal files if you do not specify the extension.</p>

<h4>Extension Truncation</h4>

<p>The corollary to this extension priority is that we can't accurately distinguish between two extensions on the client when we omit the extension.
Thus, since omitting the extension is generally advantageous for brevity, we have decided to simply truncate the extension on the client.</p>

<p>This is advantageous also because it makes the require code leaner, more perfomant, and each <strong>dom::name pair is unique</strong>, as they should be.</p>

<p>You can still have a <code>.js</code> duplicate of your <code>.coffee</code> file in a directory, but you then have to explicitly define <code>.coffee</code> so that the server
can pre-pick the right one to include for you.</p>

<h4>Server Error</h4>

<p>To help you remember this, modul8 will actually throw an error if you simultaneously try to require both</p>

<ul>
<li>app::subpath/module.js</li>
<li>app::subpath/module.otherExt</li>
</ul>

<p>It is not a complete failsafe, but it helps force usage so that the problem above does not occur.</p>

<p><strong>In short</strong>: try not to have different extension versions of your files in the same directory or you can run into the following two problems:</p>

<ul>
<li><strong>A)</strong> your Coffee changes won't do anything because you are unknowingly requiring a JS version that got in the directory</li>
<li><strong>B)</strong> you will have a conflict error thrown at you to help you not challenging fate with techniques that can result in problem A</li>
</ul>

<p>Note that the error will only be thrown after the <code>.analysis()</code> dependency tree was logged, allowing you to pinpoint the careless <code>require()</code>.</p>

<h2>Require Priority</h2>

<p>Require priority will mostly follow the nodejs require algorithm, but with some slight modifications to get cross domain requires working without require.paths.</p>

<h3>Folders Priority</h3>

<p>Require strings that contain a trailing slash or does not point to a file directly, will try to resolve the name as a folder and look for a file named <code>index</code> following the above logic.
The following will all resolve a folder, but the last has the possiblility of a collision with a file of the same name as the folder:</p>

<pre><code>require('controllers/index');
require('controllers/'); //looks for controllers/index+extension
require('controllers'); //looks for controllers+extension then controllers/index+extension
</code></pre>

<h3>General Priority</h3>

<p>Requires are attempted resolved with the following priority:</p>

<pre><code>if require string is relative
  resolve require string using current path on current domain
if require string includes npm prefix or is from npm domain
  require node modules from builtins or from current node_modules subdir or above one recursively
else if require string includes domain prefix
  resolve require string on specified domain absolutely
else //try arbiter search
  resolve require string on the M8 domain

if none of the above true
  resolve on all real domains, starting with current domain

//error
</code></pre>

<p>In other words, collisions should not occur unless you have duplicate files in different domains and
you are overly relaxed about your domain specifiers, or you have actual files with arbiter names lying around.</p>    </div>
  </body>
</html>
