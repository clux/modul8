<html>
  <head>
    <meta charset="utf8">
    <title>modul8 - Extensible CommonJS for the Browser</title>
    <link rel='stylesheet' href='../main.css' />
  </head>
  <body class="subpage">
    <ul id="nav">
      <li><a href="https://github.com/clux/modul8#readme" title="Source and introduction">Intro</a></li>
      <li><a href="https://github.com/clux/modul8/tree/master/examples" title="Examples from github source">Examples</a></li>
      <li><a href="api.html" title="API documentation">API</a></li>
      <li><a href="cli.html" title="using the Command Line Interface">CLI</a></li>
      <li><a href="require.html" title="require() types and priorities">require</a></li>
      <li><a href="xcjs.html" title="Extended CommonJS: basic and extensions">X-CommonJS</a></li>
      <li><a href="modularity.html" title="Modularity: issues and advice">Modularity</a></li>
    </ul>
    <div id="content">
<h1>require()</h1>

<p>modul8's <code>require()</code> works hand in hand with a private <code>define()</code> call that will wrap each module in the compiled source.
This ensures that each module has the necessary context for the <code>require()</code> calls it will make. All this context is stored via closures and will be hidden from you.</p>

<h2>Ways to require</h2>

<p>There are four different ways to use require:</p>

<h4>Absolutely</h4>

<ul>
<li><code>require('subfolder/module.js')</code> - Can resolve subfolder/module.js on any domain - regardless of what subfolder or domain you are in - but will scan the current domain first.</li>
</ul>

<h4>Relatively</h4>

<ul>
<li><code>require('./module.js')</code> - Can resolve a module.js file on the current domain in the current folder.</li>
</ul>

<p>You can indicate a relative require by using either the <code>./</code> prefix, or the folder traversing <code>../</code> prefix. Going up folders is done by chaining on <code>../</code> strings.</p>

<p><strong>Note</strong> that all the <code>../</code> chaining has to happen in the beginning of the require string (easy convention on the client). In other words:</p>

<ul>
<li><code>require('./../subfolder/../basemodule.js')</code> <strong>is not legal</strong> while <code>require('./../basemodule.js')</code> <strong>is</strong>.</li>
</ul>

<h4>Domain Specific</h4>

<ul>
<li><code>require('shared::val.js')</code> - Like absolute requires, but specifies the only domain which will be searched. If you want to do relative domain specific requires,
just use a pure relative require where the current domain is implicitly assumed.</li>
</ul>

<h5>Data Domain</h5>

<ul>
<li><code>require('data::datakey')</code> - Data on this domain does not represent actual files, but data injected into the require system on the server. It will not show up in the dependency tree.</li>
</ul>

<h5>External Domain</h5>

<ul>
<li><code>require('external::extkey')</code> - Same as data domain, but only extensible from the client.</li>
</ul>

<h5>Arbiter Domain</h5>

<ul>
<li><code>require('jQuery')</code> - Shortcut domain for old globals that were deleted to help identify hidden dependencies - must be defined on the server.
This does not require a domain prefix because it is assumed this domain gets sufficiently frequent use to have it bumped up on the priority list.</li>
</ul>

<p>Note that if a jQuery.js file is found on the current domain, however, it will gain priority over the arbiter domain.
If this coexistence is necessary, any arbiters must be  required by specifying the internal domain name: <code>$ = require('M8::jQuery')</code>.</p>

<h2>File extensions</h2>

<p>File extensions are never necessary, but you can (and sometimes should) include them for specificity (except for on the data domain).</p>

<p>The reason you perhaps should is that modul8 allows mixing and matching JavaScript, CoffeeScript, and other AltJS languages,
but is only as forgiving with such mixing as you deserve. If you only use one language and never put files of another language in your directories,
the following warning does not apply to you.</p>

<h3>Extension Priority</h3>

<p>To see why, consider a simplified resolver algorithm from the server</p>

<pre><code>name = require input, domain = domain of requiree
while(domain)
  return true if exists(domain + name)
  return true if exists(domain + name + '.js')
  return true if exists(domain + name + '.coffee')
  return true if exists(domain + name + altJsExt) //optional
  domain = nextDomain // if applicable (see require priority below)
return false
</code></pre>

<p>If you use <em>CoffeeScript</em> or other registered compilers for AltJS languages,
and if there is even a chance of a file of the same name with a <code>.js</code> extension popping up in the same folder,
then it will gain priority over your normal files if you do not specify the extension.</p>

<h4>Extension Truncation</h4>

<p>The corollary to this extension priority is that we can't accurately distinguish between two extensions on the client when we omit the extension.
Thus, since omitting the extension is generally advantageous for brevity, we have decided to simply truncate the extension on the client.</p>

<p>This is advantageous also because it makes the require code leaner, more perfomant, and each <strong>dom::name pair is unique</strong> as they should be.</p>

<p>You can still have a <code>.js</code> duplicate of your <code>.coffee</code> file in a directory, but you then have to explicitly define <code>.coffee</code> so that the server
can pre-pick the right one to include for you.</p>

<h4>Server Error</h4>

<p>To help you remember this, modul8 will actually throw an error if you simultaneously try to require both</p>

<ul>
<li>app::subpath/module.js</li>
<li>app::subpath/module.otherExt</li>
</ul>

<p>It is not a complete failsafe, we are aware, but it helps force usage so that the problem above does not occur.</p>

<p>In short: try not to have different extension versions of your files in the same directory or you can run into the following two problems:</p>

<ul>
<li><strong>A)</strong> your Coffee changes wont do anything because you are unknowingly requiring a JS version that got in the directory</li>
<li><strong>B)</strong> you will have a conflict error thrown at you to help you not challenging fate with techniques that can result in problem A</li>
</ul>

<p>Note that the error will only be thrown after the <code>.analysis()</code> dependency tree was logged, allowing you to pinpoint the careless <code>require()</code>.</p>

<h2>Folders Priority</h2>

<p>Require strings that contain a trailing slash or does not point to a file directly, will try to resolve the name as a folder and look for a file named <code>index</code> following the above logic.
The following will all resolve a folder, but the last has the possiblility of a collision with a file of the same name as the folder:</p>

<pre><code>require('controllers/index');
require('controllers/'); //looks for controllers/index+extension
require('controllers'); //looks for controllers+extension then controllers/index+extension
</code></pre>

<h2>General Priority</h2>

<p>Requires are attempted resolved with the following priority:</p>

<pre><code>if require string is relative
  resolve absolutized require string on current domain
else if require string includes domain prefix
  resolve require string on specified domain
else //try arbiter search
  resolve require string on the M8 domain

if none of the above true
  resolve on all real domains, starting with current domain

//error
</code></pre>

<p>In other words, collisions should not occur unless you have duplicate files in different domains and
you are overly relaxed about your domain specifiers, or you have actual files with arbiter names lying around.</p>

<h2>Hooking into define</h2>

<p>modul8 defines way to help you attach objects/fn to certain domains both live on the client and from the server.
The <a href="api.html">API docs</a> have full information on these features.</p>    </div>
  </body>
</html>
