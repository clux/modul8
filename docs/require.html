<html>
  <head>
    <meta charset="utf8">
    <title>modul8 - Extensible CommonJS for the Browser</title>
    <link rel='stylesheet' href='../main.css' />
  </head>
  <body class="subpage">
    <ul id="nav">
      <li><a href="api.html" title="API documentation">API</a></li>
      <li><a href="require.html" title="require() types and priorities">require</a></li>
      <li><a href="commonjs.html" title="CommonJS parsing - our implementation">CommonJS</a></li>
      <li><a href="modularity.html" title="Modularity issues and advice">Modularity</a></li>
    </ul>
    <div id="content">
<h1>require()</h1>

<p>Modul8's <code>require()</code> works hand in hand with a private <code>define()</code> call that gets pre-pended to the compiled source.
On compilation each module is wrapped in a define call (ensuring encapsulation of private variables between modules) that give each of these modules
the necessary context for the <code>require()</code> calls it may make. All context is stored via closures and will be hidden from you.</p>

<h2>Ways to require</h2>

<p>There are four different ways to use require:</p>

<ul>
<li><p><strong>Globally</strong>:        <code>require('subfolder/module.js')</code>. This will scan all the domains (except data) for a matching structure, starting the search at your current location.
A gloabl require does not care about your current location.</p></li>
<li><p><strong>Relatively</strong>:      <code>require('./module.js')</code>. This will scan only the current domain and the current folder
You can keep chaining on '../' to go up directories, but this has to happen in the beginning of the require string:</p>

<p><code>require('./../subfolder/../basemodule.js')</code> <strong>is not legal</strong> while <code>require('./../basemodule.js')</code> <strong>is</strong>.</p></li>
<li><p><strong>Domain Specific</strong>  <code>require('shared::val.js')</code>. Scans the specified domain (only) as if it were a global require from within that domain.
You cannot do relative requires combined with domain prefixes as this is either non-sensical (cross domain case: folder structure between domains lost on the browser),
or unnecessary (same origin case: you should simply be using relative requires).</p></li>
<li><p><strong>Data Domain</strong>:     <code>require('data::datakey')</code>. The data domain is special. It is there to allow requiring of data that was <code>add()</code>-chained on the <code>data()</code> method.
It does not arise from physical files, and will not show up in the dependency tree. It is simply data you have attached deliberately.</p></li>
<li><p><strong>Through Arbiters</strong> <code>require('jQuery')</code> - given that <code>arbiters().add('jQuery',['$','jQuery'])</code> was passed in on the server.
This will have deleted the global shortcuts included. Since these are probably commonly dependend upon they can be used without specifying their default domain: <code>M8::</code>.</p>

<p>Note that this domain name is not related to the namespace setting. If a jQuery.js file is found on the current domain, however, it will gain priority over the
arbiters domain. If this coexistence is necessary, any arbiters must be  required by specifying the internal domain: <code>$ = require('M8::jQuery')</code>.</p></li>
</ul>

<h3>File extensions</h3>

<p>File extensions are never necessary, but you can (and sometimes should) include them for specificity (except for on the data domain).</p>

<p>The reason you perhaps should is that  modul8 allows mixing and matching JavaScript, CoffeeScript, and other altJs languages,
but is only as forgiving with such mixing as you deserve.</p>

<h4>Server Behaviour</h4>

<p>To see why, consider a simplified resolver algorithm from the server</p>

<pre><code>name = require input, domain = domain of requiree
while(domain)
  return true if exists(domain + name)
  return true if exists(domain + name + '.js')
  return true if exists(domain + name + '.coffee')
  return true if exists(domain + name + altJsExt) //optional
  domain = nextDomain // if applicable (see require priority below)
return false
</code></pre>

<p>If you use <em>CoffeeScript</em> or other registered compilers for altJs languages,
and if there is even a chance of a file of the same name with a <code>.js</code> extension popping up in the same folder,
then you <em>should only</em> use <code>require()</code> with an explicitly specified file extension.</p>

<p>In short: <strong>DO NOT omit extensions and keep .js and .coffee versions in the same folder</strong>
or you will quickly become very frustrated as to why your coffee changes arent doing anything.</p>

<h4>Client Behaviour</h4>

<p>modul8 will truncate the extension from the name passed to the internal <code>define()</code> wrapper.
This has two advantages:</p>

<ul>
<li><code>require()</code> lookups on the client will be performant and slim (no need to do multiple lookups against multiple possible extensions - as it will simply chuck the extension part)</li>
<li>It discourages the unsafe practice having files of the same name in the same directory</li>
</ul>

<p>However, the server side collision problem applies. modul8 will only be able to <code>define()</code> one of</p>

<ul>
<li>domain::filename.coffee</li>
<li>domain::fiename.js</li>
</ul>

<p>If you do use extensions (even partially), then modul8 will throw an error if multiple versions of domain::filename was attempted to be included.
This error will be usefully be thrown after the <code>.analysis()</code> dependency tree was logged, allowing you to pinpoint the careless <code>require()</code>.</p>

<h3>Require Folders</h3>

<p>Require strings not resolving as a file, or ending in a slash will try to resolve the name as a folder and look for a file named <code>index</code> following the above logic.
The following will all resolve a folder, but the last has the possiblility of a collision with a file of the same name as the folder:</p>

<pre><code>require('controllers/index');
require('controllers/'); //looks for controllers/index+extension
require('controllers'); //looks for controllers+extension then controllers/index+extension
</code></pre>

<h3>Require Priority</h3>

<p>Requires are attempted resolved with the following priority:</p>

<pre><code>if require string is relative
  resolve absolutized require string on current domain
else if require string includes domain prefix
  resolve require string on specified domain
else //arbiter search
  resolve require string on the M8 domain

if none of the above true
  resolve on all domains, starting with current domain

//error
</code></pre>

<p>In other words, collisions should not occur unless you have duplicate files in different domains, and you are very relaxed about your domain specifiers or arbiter prefixes.</p>

<h3>Hooking into define</h3>

<p>modul8 defines way to help you attach objects/fn to certain domains both live on the client and from the server via <code>data()</code>.
The <a href="api.html">API docs</a> have full information on this.</p>    </div>
  </body>
</html>
