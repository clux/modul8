<html>
  <head>
    <meta charset="utf8">
    <title>modul8 - Extensible CommonJS for the Browser</title>
    <link rel='stylesheet' href='../main.css' />
  </head>
  <body class="subpage">
    <ul id="nav">
      <li><a href="api.html" title="API documentation">API</a></li>
      <li><a href="cli.html" title="using the Command Line Interface">CLI</a></li>
      <li><a href="require.html" title="require() types and priorities">require</a></li>
      <li><a href="commonjs.html" title="CommonJS parsing - our implementation">CommonJS</a></li>
      <li><a href="modularity.html" title="Modularity issues and advice">Modularity</a></li>
    </ul>
    <div id="content">
<h1>Command line tool</h1>

<p>modul8 defines an optional command line tool if installed globally with npm, i.e.</p>

<pre><code>$ npm install -g modul8
</code></pre>

<p>This tool is more restrictive than modul8, because it tries to expose the core functionality in as minimal way as possible.
You cannot use it to include your libraries, but these are just concatenated on before the main output anyway, so you could do this manually yourself.</p>

<h2>Usage</h2>

<h3>Basic</h3>

<p>If you have a directory structure like so:</p>

<pre><code>code
├───app
└───shared
</code></pre>

<p>With your main application files in <code>code/app/</code>, with an entry point <code>entry.js</code> on that path, and shared code in <code>code/shared/</code>,
then it suffices to:</p>

<pre><code>$ modul8 app/entry.js -p shared:shared/ &gt; output.js
</code></pre>

<p>from the <code>code/</code> directory.</p>

<p>This assumes the name of the main domain is the name of the folder where <code>entry</code> lives, i.e. <code>app</code> in this case.</p>

<p>If you want to hold of the DOM using jQuery, append the <code>-w jQuery</code> option (see wrapper below).</p>

<h3>Advanced</h3>

<h4>Domains</h4>

<p>Multiple domains are specified using a comma separated list of name:path values.</p>

<pre><code>$ modul8 app/entry.js -p shared:shared/,bot:../libs/bot/ &gt; output.js
</code></pre>

<h3>Arbiters</h3>

<p>Loading of arbiters works like the programmatic API:</p>

<pre><code>$ modul8 app/entry.js -a jQuery:jQuery.$,Spine:Spine &gt; output.js
</code></pre>

<p>We can omit the colon for arbiters were the shortcut has the same name as the global.</p>

<pre><code>$ modul8 app/entry.js -a jQuery:jQuery.$,Spine &gt; output.js
</code></pre>

<p>The globals to delete for a given shortcut is delimited by a dot.</p>

<h3>Data Injection</h3>

<p>Data injection works fundamentally different from the shell than from your node program. Here you rely on your data pre-existing in a <code>.json</code> file and specify what key to attach it to.</p>

<pre><code>$ modul8 app/entry.js -d myKey:myData.json &gt; output.js
</code></pre>

<p>Multiple data files can be imported by comma separating the above -d input</p>

<pre><code>$ modul8 app/entry.js -d myKey:myData.json,mySecondKey:mySecondData.json &gt; output.js
</code></pre>

<h3>Extra Options</h3>

<p>The following are equivalent methods for the programmatic API calls to <code>.set()</code></p>

<pre><code>-w or --wrapper &lt;str&gt; &lt;==&gt; set('domloader', &lt;str&gt;)
-n or --namespace &lt;str&gt; &lt;==&gt; set('namespace', &lt;str&gt;)
-l or --logging &lt;==&gt; set('logging', true)
</code></pre>

<h4>Booleans</h4>

<p>The following are slightly limited versions of the programmatic API's <code>.before()</code>, <code>.after()</code> and <code>.analysis()</code></p>

<pre><code>-t or --testcutter &lt;==&gt; before(modul8.testcutter)
-m or --minifier &lt;==&gt; after(modul8.minifier)
-z or --analyze &lt;==&gt; analysis(console.log) &amp;&amp; !compile()
</code></pre>

<p>The <code>-z</code> flag will in other words not compile anything, just print the dependency tree.</p>    </div>
  </body>
</html>
